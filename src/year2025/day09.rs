//! # 2025 day 9 - Movie Theater
//!
//! ## Part 1
//!
//! The input is stored in a list of all possible rectangles that can be created with two points,
//! and sorted by their area. The largest possible area can then be retrieved from the last element
//! in the list.
//!
//! ## Part 2
//!
//! Sort of a brute force solution.
//! Along with the sorted list of rectangles, a list of lines generated by two consecutive points in
//! the input is also created. Then each rectangle is validated by checking if there are any line that
//! intersects its borders. This requires iterating through every single line to validate a single
//! rectangle, but by iterating over the sorted rectangle list we can stop once we find a valid rectangle,
//! since that will then be the largest possible, greatly reducing the number of rectangles that needs
//! to be processed.
//!
//! Not a slow solution by any means, but I might want to look into "sweep line algorithm" in the future
//! for possible improvements.
use std::{error::Error, str::FromStr};

use crate::aoc_util::point::Point;

pub fn solve(input: &str) -> Result<(String, String), Box<dyn Error>> {
    let solution_data = InputData::from_str(input).unwrap();
    Ok((
        solution_data.solve_part1().to_string(),
        solution_data.solve_part2().to_string(),
    ))
}

#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct Rectangle {
    area: u64,
    upper_left: Point,
    lower_right: Point,
}

impl Rectangle {
    fn new(p1: &Point, p2: &Point) -> Self {
        let min_x = p1.x.min(p2.x);
        let max_x = p1.x.max(p2.x);
        let min_y = p1.y.min(p2.y);
        let max_y = p1.y.max(p2.y);
        let area = (1 + max_x - min_x) as u64 * (1 + max_y - min_y) as u64;
        Self {
            area,
            upper_left: Point::new(min_x, min_y),
            lower_right: Point::new(max_x, max_y),
        }
    }
}

struct Line {
    base_point: Point,
    length: i32,
    is_horizontal: bool,
}

impl Line {
    fn new(p1: &Point, p2: &Point) -> Option<Self> {
        if p1.x == p2.x {
            let length = p1.y.abs_diff(p2.y) as i32;
            Some(Self {
                base_point: Point::new(p1.x, p1.y.min(p2.y)),
                length,
                is_horizontal: false,
            })
        } else if p1.y == p2.y {
            let length = p1.x.abs_diff(p2.x) as i32;
            Some(Self {
                base_point: Point::new(p1.x.min(p2.x), p1.y),
                length,
                is_horizontal: true,
            })
        } else {
            None
        }
    }

    fn intersects_rectangle(&self, r: &Rectangle) -> bool {
        // Note: this will also consider a line completely inside the rectangle as intersecting. Since all lines are contiguous,
        // then if one individual line is inside then another line WILL intersect somewhere, so we might as well invalidate
        // the rectangle already now.
        if self.is_horizontal {
            (r.upper_left.y + 1..r.lower_right.y).contains(&self.base_point.y)
                && self.base_point.x < r.lower_right.x
                && self.base_point.x + self.length > r.upper_left.x
        } else {
            (r.upper_left.x + 1..r.lower_right.x).contains(&self.base_point.x)
                && self.base_point.y < r.lower_right.y
                && self.base_point.y + self.length > r.upper_left.y
        }
    }
}

struct InputData {
    rectangles: Vec<Rectangle>,
    lines: Vec<Line>,
}

impl FromStr for InputData {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let red_tiles: Vec<_> = s
            .lines()
            .map(|line| Point::from_str(line).unwrap())
            .collect();
        let mut rectangles = Vec::new();
        for i in 0..red_tiles.len() - 2 {
            // Note: skip the first following entry, since that will effectively only make a line rather than a rectangle
            for j in i + 2..red_tiles.len() {
                rectangles.push(Rectangle::new(&red_tiles[i], &red_tiles[j]));
            }
        }
        rectangles.sort_unstable();
        let mut lines: Vec<_> = red_tiles
            .windows(2)
            .map(|p| Line::new(&p[0], &p[1]).unwrap())
            .collect();
        lines.push(Line::new(red_tiles.last().unwrap(), red_tiles.first().unwrap()).unwrap());
        Ok(Self { rectangles, lines })
    }
}

impl InputData {
    fn is_rectangle_valid(&self, r: &Rectangle) -> bool {
        !self.lines.iter().any(|line| line.intersects_rectangle(r))
    }

    fn solve_part1(&self) -> u64 {
        self.rectangles.last().unwrap().area
    }

    fn solve_part2(&self) -> u64 {
        for rectangle in self.rectangles.iter().rev() {
            if self.is_rectangle_valid(rectangle) {
                return rectangle.area;
            }
        }
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TEST_DATA: &str = "7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3";

    #[test]
    fn part1_example_1() {
        let solution_data = InputData::from_str(TEST_DATA).unwrap();
        assert_eq!(solution_data.solve_part1(), 50);
    }

    #[test]
    fn part2_example_1() {
        let solution_data = InputData::from_str(TEST_DATA).unwrap();
        assert_eq!(solution_data.solve_part2(), 24);
    }
}
